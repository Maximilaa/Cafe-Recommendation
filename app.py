# -*- coding: utf-8 -*-
"""app
Automatically generated by Colab.
Original file is located at
    https://colab.research.google.com/drive/16gW4FijDtLhFvXKEszsGFFbm83PYFFSf
"""

import streamlit as st
import pandas as pd
import torch
import numpy as np
from transformers import BertTokenizer, BertForSequenceClassification
from sklearn.metrics.pairwise import cosine_similarity
from huggingface_hub import hf_hub_download

# =========================
# CONFIG
# =========================
st.set_page_config(
    page_title="Coffee Recommender",
    layout="wide"
)

# Parameter sesuai Bab IV
ALPHA = 0.7   # Bobot hybrid 
TOP_N = 5
MAX_LEN = 320 # Sesuai cek.pdf hal 40 & 42 

# =========================
# LOAD ASSETS
# =========================
@st.cache_resource
def load_assets():
    # Dataset sesuai Tabel 4.1 
    with st.spinner:
        csv_path = hf_hub_download(repo_id=REPO_ID, filename="processed_coffee.csv")
        df = pd.read_csv(csv_path)
        # Download model (Fine-tuned BERT)
        REPO_ID = "lattezice/cafe-sentiment-bert"
        try:
            model_path = hf_hub_download(
                repo_id=REPO_ID,
                filename="best_model.pt"
            )
        except:
            # Fallback jika struktur folder di repo berbeda
            model_path = hf_hub_download(repo_id=REPO_ID, filename="best_model.pt")
    
        tokenizer = BertTokenizer.from_pretrained("bert-base-uncased")
    
    # Menggunakan BertForSequenceClassification (3 label: Positif, Netral, Negatif) [cite: 801, 816]
    model = BertForSequenceClassification.from_pretrained("bert-base-uncased", num_labels=3)

    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    
    # Load state dict dengan safe loading
    state_dict = torch.load(model_path, map_location=device)
    model.load_state_dict(state_dict, strict=False)
    model.to(device)
    model.eval()

    # Load precomputed assets (Pastikan file ini ada di folder yang sama)
    cafe_emb = np.load("cafe_embedding.npy")      
    sentiment_score = np.load("sentiment_score.npy")  

    return df, tokenizer, model, cafe_emb, sentiment_score, device

# Eksekusi Load
try:
    df, tokenizer, model, cafe_emb_matrix, sentiment_score_vec, device = load_assets()
except Exception as e:
    st.error(f"Gagal memuat assets: {e}")
    st.stop()

# =========================
# HELPER FUNCTION
# =========================
def encode_text(text):
    # Tokenisasi sesuai Bab 4.4.1 [cite: 828]
    inputs = tokenizer(
        text,
        return_tensors="pt",
        truncation=True,
        padding="max_length",
        max_length=MAX_LEN
    ).to(device)

    with torch.no_grad():
        outputs = model.bert(**inputs) # Mengambil base bert dari classification model
        # Mengambil [CLS] token sebagai representasi ulasan [cite: 499, 869]
        emb = outputs.last_hidden_state[:, 0, :]  

    return emb.cpu().numpy().flatten()

# =========================
# UI (UX tetap sama)
# =========================
st.title("‚òï Coffee Recommender")
st.markdown("Sistem Rekomendasi Caf√© Berbasis Embedding & Sentimen")

with st.form("recommender_form"):
    user_text = st.text_area(
        "Preferensi Caf√© (contoh: cozy quiet place for studying)",
        height=120
    )

    col1, col2 = st.columns(2)
    with col1:
        city = st.selectbox("City", sorted(df["city"].dropna().unique()))
    with col2:
        state = st.selectbox("State", sorted(df["state"].dropna().unique()))

    submitted = st.form_submit_button("Cari Rekomendasi")

# =========================
# RECOMMENDATION LOGIC
# =========================
if submitted:
    if user_text.strip() == "":
        st.warning("Masukkan preferensi caf√© terlebih dahulu.")
    else:
        with st.spinner("Menganalisis preferensi..."):
            # 1. Encode user preference [cite: 512, 917]
            user_emb = encode_text(user_text).reshape(1, -1)

            # 2. Perhitungan Cosine Similarity [cite: 511, 919]
            similarity_scores = cosine_similarity(
                user_emb,
                cafe_emb_matrix
            )[0]

            # 3. Perhitungan Hybrid Score (Linear Combination) [cite: 919, 921]
            # Hybrid Score = (ALPHA * Semantic) + ((1 - ALPHA) * Sentiment)
            hybrid_scores = (
                ALPHA * similarity_scores
                + (1 - ALPHA) * sentiment_score_vec
            )

            # 4. Integrasi ke DataFrame
            result_df = df.copy()
            result_df["semantic_similarity"] = similarity_scores
            result_df["sentiment_score"] = sentiment_score_vec
            result_df["hybrid_score"] = hybrid_scores

            # 5. Filter Lokasi [cite: 929]
            result_df = result_df[
                (result_df["city"] == city) &
                (result_df["state"] == state)
            ]

            if result_df.empty:
                st.error(f"Tidak ada caf√© ditemukan di {city}, {state}.")
            else:
                # 6. Ranking berdasarkan Hybrid Score [cite: 921, 922]
                result_df = (
                    result_df
                    .sort_values("hybrid_score", ascending=False)
                    .drop_duplicates("business_id")
                    .head(TOP_N)
                )

                # Output UI
                st.subheader("üéØ Rekomendasi Caf√©")
                # Menampilkan kolom sesuai Tabel 4.11 [cite: 931, 934]
                display_cols = ["cafe_name", "categories", "cafe_rating", "hybrid_score"]
                
                st.dataframe(
                    result_df[display_cols].reset_index(drop=True),
                    use_container_width=True
                )
